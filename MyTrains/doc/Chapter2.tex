% Activate the following line by filling in the right side. If for example the name of the root file is Main.tex, write
% "...root = Main.tex" if the chapter file is in the same directory, and "...root = ../Main.tex" if the chapter is in a subdirectory.
 
%!TEX root =  

\chapter[Fast Clock]{Fast Clock}

\section{Summary}

The command station provides a system fast clock and parameters are stored in slot \#123 (0x7B). Use OPC\_WR\_SL\_DATA to write new clock information, The current slot information can be read using OPC\_RQ\_SL\_DATA. This will return an OPC\_SL\_RD\_DATA message containing the fast clock information. This message is called the ``sync". Other throttles will update to this sync. Note that all attached display devices keep a current clock calculation based on this sync read value, i.e. devices must not continuously poll the clock slot to generate time, but use this merely to restore sync and follow current rate etc. The clock slot is typically ``pinged" or read every 70 to 100 seconds, by a single user, so all attached devices can synchronise any phase drifts. Upon seeing a sync read, all devices should reset their local sub-minute phase counter and invalidate the sync update ping generator.

\section{Slot \#123 Encoding}

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 1 & 1 & 1 & 1 & 0 & 1 & 1\\
\hline
\end{tabular}
& 0x7B & Slot number.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$RATE$>$ & Clock rate. 0x00 means freeze clock, 0x01 means 1:1 rate, 0x0A means 10:1,  etc. The maximum value 0x7F means 128:1.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$FRACL$>$ & Sub-minute counter low bits.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$FRACH$>$ & Sub-minute counter high bits.\\
\end{tabular}

The implementation and meaning of FRACL and FRACH depend upon the specific clock generator. These values should not be used externally. These values are reset when a valid sync message is seen.

That said, the following timing was derived for the DCS240.

Get:

maxTick = 0xBFF

ticks =  maxTick - (0x3FFF - (($<$FRACL$>$ \& 0x7F) | (($<$FRACH$>$ \& 0x7F) $<<$ 7)))
 
seconds = 60.0 * ticks / (maxTick + 1)

Set:

temp = ticks - maxTick + 0x3FFF

$<$FRACL$>$ = temp \& 0x7F

$<$FRACH$>$ = (temp $>>$ 7) \& 0x7F
 
Byte 4:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$MINS$>$ & Fast clock minutes. This is encoded.\\
\end{tabular}

Get:

temp = ((255 - $<$MINS$>$) \& 0x7F) mod 60

minutes =  (60 - temp) mod 60

Set:

 $<$MINS$>$ = (255 - (60 - minutes)) \& 0x7F

Byte 5:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$TRK$>$ & Global system track status.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & Reserved. Set to 0.\\
d5 & Reserved. Set to 0.\\
d4 & Reserved. Set to 0.\\
d3 & 1 means the programming track is busy.\\
d2 & 1 means this master implements the Network version 1.1 capability,  0 means the master is a DT200.\\
d1 & 0 means the track is paused, broadcast an emergency stop.\\
d0 & 1 means the DCC packets are on in the master, global power up.\\
\end{tabular}

Byte 6:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$HRS$>$ & Fast clock hours. This is encoded.\\
\end{tabular}

Get:

temp = ((256 - $<$HRS$>$) \& 0x7F) mod 24

hours =  (24 - temp) mod 24

Set:

$<$HRS$>$ = (256 - (24 - hours)) \& 0x7F
   
Byte 7:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$DAYS$>$ & Fast clock days. Number of 24 hour clock rolls.\\
\end{tabular}

Byte 8:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
& $<$CNTRL$>$ & The bit d6 indicates valid clock information. 1 means good and 0 means ignore.\\
\end{tabular}

Byte 9:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$ID1$>$ & Device ID low bits.\\
\end{tabular}

Byte 10:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.375\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$ID2$>$ & Device ID high bits.\\
\end{tabular}

ID1 and ID2 indicate the device that last set the clock. 0x00, 0x00 means that not set has happened. 0x7F, 0x7X are reserved for computer use.




