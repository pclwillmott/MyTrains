% Activate the following line by filling in the right side. If for example the name of the root file is Main.tex, write
% "...root = Main.tex" if the chapter file is in the same directory, and "...root = ../Main.tex" if the chapter is in a subdirectory.
 
%!TEX root =  

\chapter[Network Protocol]{The Network Protocol}.  

\section{Overview}

Loconet is a peer to peer distributed network system on which all devices can monitor the network data flow. The network is event driven by different devices in time, and is not polled by a centralised controller in normal operation. The normal the network state is idle, with no data traffic unless a device has information to send. With no traffic flow, the network is quiet.

The network data is sent in asynchronous format using 1 start bit, 8 data bits and 1 stop bit. The 8 bit data is transmitted least significant bit first. The bit times are 60.0 $\mu$S or 16,660 baud +/- 1.5\%. A computer can connect to a Digitrax USB interface at higher baud rates and the device will make the necessary conversion. Bytes may be transmitted back-to-back, with a start bit immediately following the stop bit of the previous character. 

Any message that has format or framing errors, data errors or is a fragment caused by noise glitches and does not completely follow the message format will be ignored by all receivers, and a new opcode will be scanned for re-synchronisation.

The OPC\_BUSY opcode is included to allow the master to keep the network active whilst it is performing a task that requires a response, and entails a significant processing delay, i.e. it can ensure no new requests are started until it has responded to the last message. This OPC\_BUSY opcode should be simply stripped and ignored.

If a device disconnects from the network and so does not access or reference a slot within the system purge time, the command station will force the un-accessed slot to common status so other system devices can use the slot. The typical purge time of a command station is about 200 seconds. A good ``ping" or slot update activity is about every 100 seconds, i.e. if a user makes no change to a throttle/slot within 100 seconds, the throttle/device should automatically send another speed update at the current speed to reset the purge timeout for that slot.

\section{Message Format}

All the network communications are via multi-byte messages. The command station is defined as the device that is maintaining the refresh stack for DCC packet generation and is actively generating the DCC track data. Refresh of information is typically only performed for mobile decoders. Stationary type decoders are not refreshed and individual immediate commands are sent out to the track as requested.

The command station is only privileged in respect to performing the task of maintaining the locomotive refresh stack and generating DCC packets. In this way other network transactions may occur that the command station does not need to be involved with or understand, as long as they follow the message protocol and timing requirements. i.e. other devices may have a dialog on the network without disturbing or involving the command station. Devices on the network monitor the messages, check for format and data integrity and parse good messages to decode if action is required in the context. Devices such as throttles, input sensors, computer interfaces and control panels may generate the network messages without needing prompting or polling by a central controller.

Devices frequently will be added and removed from an operating the network. The devices and protocol are tolerant of electrical and data transients. The format chosen gives a good degree of data integrity, guaranteed quick network-state synchronisation, high data throughput, good distribution of access to many competing devices and low event latency. Also, the devices may be operated without need for unique ID or other requirements that can make network administration awkward.

The data bytes on the Network are defined as 8 bit data with the most significant bit as an opcode flag bit. If the most significant bit, d7, is 1 then the 7 least significant bits are interpreted as a network opcode . The opcode byte may only occur once in a valid message and is the first byte of a message. All the remaining bytes in the message must have a most significant bit of 0, including the last checksum byte. The checksum is the 1's complement of the byte wise exclusive or of all the bytes in the message, except the checksum itself. To validate data accuracy, all the bytes in a correctly formatted message are exclusive or'ed. If this resulting byte value is 0xFF, then the message data is accepted as good.

The opcodes may be examined to determine message length and if subsequent response message is required. Data bits d6 and d5 encode the message length. The message length includes the opcode and the checksum bytes. The bit d3 = 1 implies that a follow-on message or reply is expected.

\begin{tabular}{p{0.05\linewidth} p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth} p{0.36\linewidth}} 
\underline{d7} & \underline{d6} & \underline{d5} & \underline{d4} & \underline{d3} & \underline{d2} & \underline{d1} & \underline{d0} & \\
1 & 0 & 0 & E & D & C & B & A & 2 byte message\\
1 & 0 & 1 & E & D & C & B & A & 4 byte message\\
1 & 1 & 0 & E & D & C & B & A & 6 byte message\\
1 & 1 & 1 & E & D & C & B & A & Variable length message. The next byte in the message is a 7 bit byte count.\\
\end{tabular}

The A,B,C,D,E are bits available to encode 32 opcodes per message length.

\section{Refresh Slots}
The command station standard refresh stack is an array of up to 120 read/write refresh slots. The slot address is a principal component and is generally the second byte or 1st argument of a message to the master. The standard refresh slot contains up to 10 data bytes relating to a locomotive and also controls a task in the track DCC refresh stack. Most mobile decoder or locomotive operations process the slot associated with the locomotive to be controlled. The slot number is a similar shorthand ID\# to a file handle. Slot addresses 120-127 are reserved for system and command station control. Slot \#124 (0x7C) is allocated for read/write access to the programming track, and the format is not the same as a standard slot. The DCS240 command station has 400 read/write refresh slots. The additional slots in excess of the 120 standard slots are accessed by using extended opcodes. The DCS210 also supports the extended opcodes though it only has 100 refresh slots.

\subsection{Slot Format}

\subsection{Extended Slot Format}

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 0 & 0 & 0 & 0 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SLOTP\#$>$ & Extended slot page number in the range 0x0 to 0x7.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SLOTL\#$>$ & Extended slot number in the range 0x00 to 0x7F.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  $<$STAT1$>$ & Slot status 1.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.05\linewidth} p{0.05\linewidth} p{0.70\linewidth}} 
& \underline{d5} & \underline{d4} & \\
& 0 & 0 & Free slot, no valid data. Not refreshed.\\
& 0 & 1 & Common. Locomotive address in this slot. Refreshed.\\
& 1 & 0 & Idle. Locomotive address in this slot. Not refreshed.\\
& 1 & 1 & In Use. Locomotive address in this slot. Refreshed. \\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$ADR$>$ & Low address.\\
\end{tabular}

Byte 4:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$ADR2$>$ & High address.\\
\end{tabular}

Byte 5:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$TRK$>$ & Global system track status.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & Reserved. Set to 0.\\
d5 & Reserved. Set to 0.\\
d4 & Reserved. Set to 0.\\
d3 & 1 means the programming track is busy.\\
d2 & 1 means this master implements the Network version 1.1 capability,  0 means the master is a DT200.\\
d1 & 0 means the track is paused, broadcast an emergency stop.\\
d0 & 1 means the DCC packets are on in the master, global power up.\\
\end{tabular}

Byte 6:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 7:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 8:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 9:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 10:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 11:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 12:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 13:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 14:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 15:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 16:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

Byte 17:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Unknown.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & \\
d5 & \\
d4 & \\
d3 & \\
d2 & \\
d1 & \\
d0 & \\
\end{tabular}

\section{Standard Address Selection}

To request a mobile or locomotive decoder task in the refresh stack, a throttle device requests a locomotive address for use (OPC\_LOCO\_ADR). The command station responds with a slot data read for the slot (OPC\_SL\_RD\_DATA), that contains this locomotive address and all of its state information. If the address is currently not in any slot, the command station will load this new locomotive address into a new slot (speed=0, direction forwards, functions off and 128 step mode) and return this as a OPC\_SL\_RD\_DATA. If no inactive slots are free to load the new locomotive address, the response will be the OPC\_LONG\_ACK with a fail code 0x00.

The throttle/computer must then examine the slot data bytes to work out how to process the command station response. If the slot status 1 byte shows the slot to be common idle or new the throttle may change the slot to in use by performing a null move instruction (see OPC\_MOVE\_SLOTS) on this slot. This activation mechanism is used to guarantee proper slot usage interlocking in a multi-user asynchronous environment.

If the slot return information shows the locomotive requested is in use or up-consisted (i.e. the SL\_CONUP, bit 6 of slot status 1 = 1) the user should not use the slot. Any up-consisted locomotives must be unlinked before usage. Always process the result from the OPC\_LINK\_SLOTS and OPC\_UNLINK\_SLOTS commands, since the command station reserves the right to change the reply slot number and can reject the linking tasks under several circumstances. Verify the reply slot number and the link UP/DN bits in slot status 1 are as you expected.

The throttle will then be able to update speed, direction and function information. Whenever slot information is changed in an active slot , the slot is flagged to be updated as the next DCC packet sent to the track. If the slot is part of linked consist slots the whole consist chain is updated consecutively.

If a throttle is disconnected from the the Network, upon reconnection (if the throttle retains the slot state from before disconnection) it will request the full status of the slot it was previously using. If the reported status and speed, function data etc., from the command station exactly matches the remembered slot state the throttle will continue using the slot. If the slot data does not match, the throttle will assume the slot was purged free by the system and will go through the setup log on procedure again.

With this procedure the throttle does not need to have a unique ID number. slot addresses do not imply they contain any particular locomotive address. The system can be mapped such that the slot address matches the locomotive address within, if the user directly reads and writes to slots without using the command station to allocate locomotive addresses.

\section{Opcodes}

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_BRD\_OPSW}
\underline{Operation:} Read and write board option switches.

\underline{Group:} \hspace{0.5cm} 6-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Command Station

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 1 & 0 & 1 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
& 0xD0 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 1 & 1 & d4 & 0 & 0 & 1 & d0\\
\hline
\end{tabular}
&  & The bit d0 is the most significant bit of the board id. Bit d4 indicates read/write direction. 1 means write and 0 means read.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$BIDL$>$ & Least significant 7 bits of the board id.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$BTYPE$>$ & Board type code.\\
\end{tabular}

\begin{tabular}{p{0.2\linewidth} p{0.5\linewidth}} 
\underline{Board} & \underline{Type Code}\\
PM4 & 0x70.\\
BDL16 & 0x71.\\
SE8C & 0x72.\\
DS64 & 0x73.\\
\end{tabular}

Byte 4:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Byte and bit number. The high nibble encodes the byte number, and the low nibble the bit number.\\
\end{tabular}

The byte number is calculated as (OpSw\# - 1) $>>$ 3 and the bit number is (OpSw\# - 1) - byte number $\times$ 8.

Byte 5:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.
\end{tabular}

\underline{Description:}

\underline{Response:} 

OPC\_LONG\_ACK.

\underline{Notes:} 

None.

\input{Chapter1-Busy}

\rule{15.1cm}{0.4pt}

\input{Chapter1-ConsistFunc}
\input{Chapter1-ForceIdleState}
\input{Chapter1-GlobalPowerOff}
\input{Chapter1-GlobalPowerOn}
\input{Chapter1-IMMPacket}
\input{Chapter1-InputRep}
\input{Chapter1-LinkSlots}
\input{Chapter1-LocoAddr}
\input{Chapter1-LocoAddrExt}
\input{Chapter1-LocoDirf}
\input{Chapter1-LocoDirfExt}
\input{Chapter1-FnExt}
\input{Chapter1-LocoReset}
\input{Chapter1-LocoSnd}
\input{Chapter1-LocoSpd}
\input{Chapter1-LocoSpdExt}
\input{Chapter1-LongAck}
\input{Chapter1-MoveSlots}
\input{Chapter1-MoveSlotsExt}
\input{Chapter1-PeerXfer}
\input{Chapter1-PeerXfer20}
\input{Chapter1-RqSlData}
\input{Chapter1-ReadStdSlotData}
\input{Chapter1-ReadCfgSlotData}

\subsubsection{OPC\_SL\_RD\_DATA\_EXT}
\underline{Operation:} Returns extended slot data.

\underline{Group:} \hspace{0.5cm} Variable-Byte Message

\underline{Direction:} \hspace{0.05cm} Command Station $\rightarrow$ 

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 1 & 1 & 0 & 0 & 1 & 1 & 0\\
\hline
\end{tabular}
& 0xE6 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 0 & 0 & 1 & 0 & 1 & 0 & 1\\
\hline
\end{tabular}
& 0x15 & Message length (21 bytes).\\
\end{tabular}

Bytes 2 to 19 encode as per extended slot bytes 0 to 17.

Byte 20:

\begin{tabular}{p{0.4\linewidth} p{0.1\linewidth} p{0.5\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.\\
\end{tabular}

\underline{Description:}

This message is sent by the command station in response to an extended slot data request.

\underline{Response:} 

None.

\underline{Notes:} 

None.

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_SLOT\_STAT1}
\underline{Operation:} Set slot status 1.

\underline{Group:} \hspace{0.5cm} 4-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Command Station

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 0 & 1 & 1 & 0 & 1 & 0 & 1\\
\hline
\end{tabular}
& 0xB5 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SLOT\#$>$ & Slot number in the range 0x00 to 0x7F.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$STAT1$>$ & Slot status 1.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.

\end{tabular}

\underline{Description:}

This function sets the slot's status 1 values.

\underline{Response:} 

None.

\underline{Notes:} 

None.

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_SV\_PROG}
\underline{Operation:} Program system variables.

\underline{Group:} \hspace{0.5cm} Variable-Byte Message

\underline{Direction:} \hspace{0.05cm} device $\rightarrow$ device  

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 1 & 1 & 0 & 0 & 1 & 0 & 1\\
\hline
\end{tabular}
& 0xE5 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 0 & 0 & 1 & 0 & 1 & 0 & 0\\
\hline
\end{tabular}
& 0x14 & Message length (20 bytes).\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SRC$>$ & Source id in the range 0x00 to 0x7F.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SV\_CMD$>$ & Specifies the SV access type.\\
\end{tabular}


Byte 4:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$DSTH$>$ & Destination id high in the range 0x00 to 0x7F.\\
\end{tabular}

Byte 5:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$HOST$>$ & Device host identifier.\\
\end{tabular}

This should be 0x00 for discover devices broadcast.

\begin{tabular}{l l}
\underline{Host Id} & \underline{Device}\\
0x01 & LNRP\\
0x04 & UT4\\
0x0C & WTL12\\
0x14 & DB210 Opto\\
0x15 & DB210\\
0x16 & DB220\\
0x1A & DCS210+\\
0x1B & DCS210\\
0x1C & DCS240\\
0x23 & PR3\\
0x24 & PR4\\
0x2A & DT402\\
0x32 & DT500\\
0x33 & DCS51\\
0x34 & DCS52\\
0x3E & DT602\\
0x51 & BXPA1\\
0x58 & BXP88\\
0x5C & UR92\\
0x63 & LNWI\\
\end{tabular}

Byte 6:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
&  & Hardware version.\\
\end{tabular}

\begin{tabular}{l l}
\underline{Host Id} & \underline{Device}\\
0x00 & Slave all\\
0x18 & Slave RF24\\
\end{tabular}

Byte 7:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
&  & Reserved.\\
\end{tabular}

Byte 8:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
&  & Software Version Number.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & version number bit 3\\
d5 & version number bit 2.\\
d4 & version number bit 1\\
d3 & version number bit 0\\
d2 & subversion number bit 2\\
d1 & subversion number bit 1\\
d0 & subversion number bit 0\\
\end{tabular}

e.g. 0x09 decodes as version 1.1.

This is set to 0x00 for discover devices broadcast message.

Byte 9:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$PXCT1$>$ & Address type code and high bits of D1 to D4.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & XC2. Address type code.\\
d5 & XC1. Address type code.\\
d4 & XC0. Address type code.\\
d3 & D4.7. High bit\\
d2 & D3.7. High bit\\
d1 & D2.7. High bit\\
d0 & D1.7. High bit\\
\end{tabular}

\begin{tabular}{p{0.1\linewidth} p{0.1\linewidth} p{0.1\linewidth} p{0.4\linewidth}} 
\underline{XC2} & \underline{XC1} & \underline{XC0} & \underline{Meaning}\\
0 & 0 & 0 & 7 bit peer to peer addresses.\\
0 & 0 & 1 & reserved.\\
0 & 1 & 0 & reserved.\\
0 & 1 & 1 & reserved.\\
1 & 0 & 0 & reserved.\\
1 & 0 & 1 & reserved.\\
1 & 1 & 0 & reserved.\\
1 & 1 & 1 & reserved.\\
\end{tabular}

Byte 10:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D1$>$ & Data item 1. Low 7 bits.\\
\end{tabular}

Byte 11:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D2$>$ & Data item 2. Low 7 bits.\\
\end{tabular}

This should be 0x01 for a discover devices broadcast message.

Byte 12:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D3$>$ & Data item 3. Low 7 bits.\\
\end{tabular}

Byte 13:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D4$>$ & Data item 4. Low 7 bits.\\
\end{tabular}

Byte 14:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$PXCT2$>$ & Data type code and high bits for D5 to D8.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & XC5. Data type code.\\
d5 & XC4. Data type code.\\
d4 & XC3. Data type code.\\
d3 & D8.7. High bit\\
d2 & D7.7. High bit\\
d1 & D6.7. High bit\\
d0 & D5.7. High bit\\
\end{tabular}

\begin{tabular}{p{0.1\linewidth} p{0.1\linewidth} p{0.1\linewidth} p{0.4\linewidth}} 
\underline{XC5} & \underline{XC4} & \underline{XC3} & \underline{Meaning}\\
0 & 0 & 0 & ANSI text string.\\
0 & 0 & 1 & reserved.\\
0 & 1 & 0 & reserved.\\
0 & 1 & 1 & reserved.\\
1 & 0 & 0 & reserved.\\
1 & 0 & 1 & reserved.\\
1 & 1 & 0 & reserved.\\
1 & 1 & 1 & reserved.\\
\end{tabular}

Byte 15:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D5$>$ & Data item 5. Low 7 bits.\\
\end{tabular}

Byte 16:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D6$>$ & Data item 6. Low 7 bits.\\
\end{tabular}

Byte 17:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D7$>$ & Data item 7. Low 7 bits.\\
\end{tabular}

Byte 18:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$D8$>$ & Data item 8. Low 7 bits.\\
\end{tabular}

Byte 19:

\begin{tabular}{p{0.4\linewidth} p{0.1\linewidth} p{0.5\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.\\
\end{tabular}

\underline{Description:}

This command sends the data from one device to another peer to peer.

\begin{tabular}{p{0.2\linewidth} p{0.1\linewidth} p{0.1\linewidth} p{0.50\linewidth}} 
\underline{SRC} & \underline{DSTL} & \underline{DSTH} & Comments\\
0x0F & 0x08 & 0x00 & Discover devices broadcast message.\\
0x0F & 0x10 & 0x00 & Discover device response.\\
\end{tabular}

\underline{Response:} 

OPC\_PEER\_XFER\_20 for discover devices.

\underline{Notes:} 

The discover response decoded peer transfer message encodes as follows:

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
D1 & IPL Version Number\\
D2 & Serial Number - low byte\\
D3 & Serial Number - high byte\\
D4 & \\
D5 & Serial Number 2 - low byte\\
D6 & Serial Number 2 - high byte\\
D7 & \\
D8 & \\
\end{tabular}

The IPL version number is encoded as follows:

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & version number bit 3\\
d5 & version number bit 2.\\
d4 & version number bit 1\\
d3 & version number bit 0\\
d2 & subversion number bit 2\\
d1 & subversion number bit 1\\
d0 & subversion number bit 0\\
\end{tabular}

e.g. 0x09 decodes as version 1.1.

These came from DigiPLII:

message Length = 20
e5 14 0f 10 00 24 00 00 00 02 00 08 07 00 00 00 00 00 00 38 

message Length = 20
e5 14 0f 08 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 08 

message Length = 20
e5 14 0f 10 00 24 00 00 00 00 00 57 13 00 00 00 00 00 00 71 

message Length = 20
e5 14 0f 10 00 1b 00 00 03 02 00 54 10 00 00 00 00 00 00 4f 

It reports PR4 with serial number 0x0788 ver 0
PR4 with serial 0x1357 ver 0
DCS240 with SN 0x0AAB ver 0.3
DCS210 with SN 0x10D4 ver 0.3

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_SW\_ACK}
\underline{Operation:} Request switch command with acknowledge.

\underline{Group:} \hspace{0.5cm} 4-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Turnout controller

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 0 & 1 & 1 & 1 & 1 & 0 & 1\\
\hline
\end{tabular}
& 0xBD & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SW1$>$ & Switch address A6 to A0.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & A6.\\
d5 & A5.\\
d4 & A4.\\
d3 & A3.\\
d2 & A2.\\
d1 & A1.\\
d0 & A0.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SW2$>$ & Switch address A10 to A7 and switch control bits.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & Reserved. Set to 0.\\
d5 & Direction. 1 means closed/green, and 0 means thrown/red.\\
d4 & Output. 1 means on, and 0 means off.\\
d3 & A10.\\
d2 & A9.\\
d1 & A8.\\
d0 & A7.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.

\end{tabular}

\underline{Description:}

Command a turnout controller to a specified state and send acknowledge.

\underline{Response:} 

OPC\_LONG\_ACK.

\underline{Notes:} 

None.

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_SW\_REP}
\underline{Operation:} Turnout sensor report.

\underline{Group:} \hspace{0.5cm} 4-Byte Message

\underline{Direction:} \hspace{0.05cm} Turnout sensor $\rightarrow$ 

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 0 & 1 & 1 & 0 & 0 & 0 & 1\\
\hline
\end{tabular}
& 0xB1 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SN1$>$ & Sensor address.\\
\end{tabular}

\begin{tabular}{p{0.5\linewidth} p{0.5\linewidth}}
\underline{SN2.d6 = 1} & \underline{SN2.d6 = 0}\\
\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & A7.\\
d5 & A6.\\
d4 & A5.\\
d3 & A4.\\
d2 & A3.\\
d1 & A2.\\
d0 & A1.\\
\end{tabular} &
\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & A6.\\
d5 & A5.\\
d4 & A4.\\
d3 & A3.\\
d2 & A2.\\
d1 & A1.\\
d0 & A0.\\
\end{tabular} \\

\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SN2$>$ & Sensor address and sensor state.\\
\end{tabular}

\begin{tabular}{p{0.555\linewidth} p{0.555\linewidth}}

\underline{SN2.d6 = 1} & \underline{SN2.d6 = 0}\\
\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & Report type. 1 means the report is an input report, and 0 means the report is an output report.\\
d5 & A0.\\
d4 & Input sensor state, 1 means sensor $>=$ 6V, 0 means sensor = 0V.\\
d3 & A11.\\
d2 & A10.\\
d1 & A9.\\
d0 & A8.\\
\end{tabular} &
\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & Report type. 1 means the report is an input report, and 0 means the report is an output report.\\
d5 & 0 means closed output line is off, 1 means the closed output line is on.\\
d4 & 0 means thrown output line is off, 1 means the thrown output line is on.\\
d3 & A10.\\
d2 & A9.\\
d1 & A8.\\
d0 & A7.\\
\end{tabular} \\

\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.

\end{tabular}

\underline{Description:}

Turnout sensor report.

\underline{Response:} 

None.

\underline{Notes:} 

None.

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_SW\_REQ}
\underline{Operation:} Request switch command.

\underline{Group:} \hspace{0.5cm} 4-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Turnout controller

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
& 0xB0 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SW1$>$ & Switch address A6 to A0.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & A6.\\
d5 & A5.\\
d4 & A4.\\
d3 & A3.\\
d2 & A2.\\
d1 & A1.\\
d0 & A0.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SW2$>$ & Switch address A10 to A7 and switch control bits.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.6\linewidth}} 
d6 & Reserved. Set to 0.\\
d5 & Direction. 1 means closed/green, and 0 means thrown/red.\\
d4 & Output. 1 means on, and 0 means off.\\
d3 & A10.\\
d2 & A9.\\
d1 & A8.\\
d0 & A7.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.
\end{tabular}

\underline{Description:}

Command a turnout controller to a specified state.

\underline{Response:} 

OPC\_LONG\_ACK if command failed, otherwise no response.

\underline{Notes:} 

The on power on the command station sends a sequence of OPC\_SW\_REQ messages with the following values of SW1 and SW2:

\begin{tabular}{l l l}
\underline{SW1} & \underline{SW2} & \underline{Purpose}\\
0x78 & 0x27\\
0x79 & 0x27\\
0x7A & 0x27\\
0x7B & 0x27\\
0x78 & 0x07 & Interrogate all PM4 inputs?\\
0x79 & 0x07 & Interrogate all BDL16 input reports?\\
0x7A & 0x07 & Interrogate all SE8 input reports?\\
0x7B & 0x07 & Interrogate all DS64 input reports.\\
\end{tabular}

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_SW\_STATE}
\underline{Operation:} Request state of switch.

\underline{Group:} \hspace{0.5cm} 4-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Switch

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 0 & 1 & 1 & 1 & 1 & 0 & 0\\
\hline
\end{tabular}
& 0xBC & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SW1$>$ & Switch address A6 to A0.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & d6 & d5 & d4 & d3 & d2 & d1 & d0\\
\hline
\end{tabular}
& $<$SW2$>$ & Switch address A10 to A7 and switch control bits.\\
\end{tabular}

\begin{tabular}{p{0.05\linewidth} p{0.8\linewidth}} 
d6 & Reserved. Set to 0.\\
d5 & Direction. 1 means closed/green, and 0 means thrown/red.\\
d4 & Output. 1 means on, and 0 means off.\\
d3 & A10.\\
d2 & A9.\\
d1 & A8.\\
d0 & A7.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.

\end{tabular}

\underline{Description:}

Request state of switch.

\underline{Response:} 

OPC\_LONG\_ACK.

\underline{Notes:} 

This needs to be tested to see what the real purpose is.

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_TRANS\_REP}
\underline{Operation:} Transponder input report.

\underline{Group:} \hspace{0.5cm} 6-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Command Station

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 1 & 0 & 1 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
& 0xD0 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
&  & A value of 0x20 means the positive detection of a transponder, 0x00 means no longer detected.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 0 & 0 & 0 & n & n & n & n\\
\hline
\end{tabular}
& $<$ZONE\#$>$ & Zone indicator (0x0 = A, 0x2 = B, 0x4 = C, 0x6 = D).\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$ADR$>$ & Locomotive address low bits.\\
\end{tabular}

Byte 4:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$ADR2$>$ & Locomotive address high bits.\\
\end{tabular}

Byte 5:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.
\end{tabular}

\underline{Description:}

\underline{Response:} 

None.

\underline{Notes:} 

None.

\rule{15.1cm}{0.4pt}
\subsubsection{OPC\_UNLINK\_SLOTS}
\underline{Operation:} Unlink slots.

\underline{Group:} \hspace{0.5cm} Variable-Byte Message

\underline{Direction:} \hspace{0.05cm} $\rightarrow$ Command Station  

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 0 & 1 & 1 & 1 & 0 & 0 & 0\\
\hline
\end{tabular}
& 0xB8 & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SL1$>$ & Slot number in the range 0x00 to 0x7F.\\
\end{tabular}

Byte 2:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$SL2$>$ & Slot number in the range 0x00 to 0x7F.\\
\end{tabular}

Byte 3:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.\\
\end{tabular}

\underline{Description:}

This command unlinks slot SL1 from slot SL2.

\underline{Response:} 

Returns OPC\_SL\_RD\_DATA or OPC\_LONG\_ACK.

\underline{Notes:} 

None.

\rule{15.1cm}{0.4pt}

\input{Chapter1-WriteStdSlotData}

\subsubsection{OPC\_WR\_SL\_DATA\_EXT}
\underline{Operation:} Write extended slot data.

\underline{Group:} \hspace{0.5cm} Variable-Byte Message

\underline{Direction:} \hspace{0.05cm} Command Station $\rightarrow$ 

\underline{Encoding:} 

Byte 0:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
1 & 1 & 1 & 0 & 1 & 1 & 1 & 0\\
\hline
\end{tabular}
& 0xEE & Opcode.\\
\end{tabular}

Byte 1:

\begin{tabular}{p{0.4\linewidth} p{0.15\linewidth} p{0.38\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & 0 & 0 & 1 & 0 & 1 & 0 & 1\\
\hline
\end{tabular}
& 0x15 & Message length (21 bytes).\\
\end{tabular}

Bytes 2 to 19 encode as per extended slot bytes 0 to 17.

Byte 20:

\begin{tabular}{p{0.4\linewidth} p{0.1\linewidth} p{0.5\linewidth}} 

\begin{tabular}{|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|p{0.3cm}|}
\hline
0 & n & n & n & n & n & n & n\\
\hline
\end{tabular}
& $<$CHK$>$ & Checksum.\\
\end{tabular}

\underline{Description:}

This command sends the slot data to the command station.

\underline{Response:} 

Returns OPC\_LONG\_ACK.

\underline{Notes:} 

None.

--------------------

\input{Chapter1-ReqInterfaceStatus}
\input{Chapter1-ReadInterfaceStatus}

PR4 Interface Status Message

\begin{verbatim}

PR4 #1

<D0> 0xe5 OPCODE
<D1> 0x10 LENGTH
<D2> 0x22 SRC
<D3> 0x22 DSTL
<D4> 0x01 DSTH
<D5> 0x00 PXCT1 <- I would have expected b4 = 1
<D6> 0x08 Serial Number Low Byte
<D7> 0x07 Serial Number High Byte - Actual serial number 0x0788
<D8> 0x16 
<D9> 0x00 
<D10> 0x00 PXCT2
<D11> 0x00 
<D12> 0x00 
<D13> 0x00 
<D14> 0x24 Product Code for PR4
<D15> 0x36  CHSUM

PR4 #2

<D0> 0xe5 OPCODE OPC_PEER_XFER
<D1> 0x10 LENGTH
<D2> 0x22 SRC
<D3> 0x22 DSTL
<D4> 0x01 DSTH
<D5> 0x00 PXCT1 
<D6> 0x57 Serial Number Low Byte
<D7> 0x13 Serial Number High Byte - Actual serial number 0x1357
<D8> 0x16 
<D9> 0x00 
<D10> 0x00 PXCT2
<D11> 0x00 
<D12> 0x00 
<D13> 0x00 
<D14> 0x24 Product Code for PR4
<D15> 0x7d CHKSUM

DCS240

<D0> 0xe5 OPCODE
<D1> 0x10 Length
<D2> 0x22 SRC
<D3> 0x22 DSTL
<D4> 0x01 DSTH
<D5> 0x00 PXCT1 <- I would have expected b4 to be 1
<D6> 0x2b Serial Number Low Byte
<D7> 0x0a  Serial Number High Byte - Actual serial number 0x0aab
<D8> 0x14 
<D9> 0x00 
<D10> 0x00 PXCT2
<D11> 0x01 Hardware Version?
<D12> 0x03 Software Version
<D13> 0x01 Hardware Version?
<D14> 0x1c Product Code for DCS240
<D15> 0x21

\end{verbatim}
