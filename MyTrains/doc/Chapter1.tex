% Activate the following line by filling in the right side. If for example the name of the root file is Main.tex, write
% "...root = Main.tex" if the chapter file is in the same directory, and "...root = ../Main.tex" if the chapter is in a subdirectory.
 
%!TEX root =  

\chapter[Network Protocol]{The Network Protocol}.  

\section{Overview}

Loconet is a peer to peer distributed network system on which all devices can monitor the network data flow. The network is event driven by different devices in time, and is not polled by a centralised controller in normal operation. The normal network state is idle, with no data traffic unless a device has information to send. With no traffic flow, the network is quiet.

The network data is sent in asynchronous format using 1 start bit, 8 data bits and 1 stop bit. The 8 bit data is transmitted least significant bit first. The bit times are 60.0 $\mu$S or 16,660 baud +/- 1.5\%. A computer can connect to a Digitrax USB interface at higher baud rates and the device will make the necessary conversion. Bytes may be transmitted back-to-back, with a start bit immediately following the stop bit of the previous character. 

Any message that has format or framing errors, data errors or is a fragment caused by noise glitches and does not completely follow the message format will be ignored by all receivers, and a new opcode will be scanned for re-synchronisation.

The \textbf{Busy} message is included to allow the command station to keep the network active whilst it is performing a task that requires a response, and entails a significant processing delay, i.e. it can ensure no new requests are started until it has responded to the last message. The \textbf{Busy} message should be simply stripped and ignored.

If a device disconnects from the network and so does not access or reference a slot within the system purge time, the command station will force the un-accessed slot to common status so other system devices can use the slot. The typical purge time of a command station is about 200 seconds. A good ``ping" or slot update activity is about every 100 seconds, i.e. if a user makes no change to a throttle/slot within 100 seconds, the throttle/device should automatically send another speed update at the current speed to reset the purge timeout for that slot.

\section{Message Format}

All the network communications are via multi-byte messages. The command station is defined as the device that is maintaining the refresh stack for DCC packet generation and is actively generating the DCC track data. Refresh of information is typically only performed for mobile decoders. Stationary type decoders are not refreshed and individual immediate commands are sent out to the track as requested.

The command station is only privileged in respect to performing the task of maintaining the locomotive refresh stack and generating DCC packets. In this way other network transactions may occur that the command station does not need to be involved with or understand, as long as they follow the message protocol and timing requirements. i.e. other devices may have a dialog on the network without disturbing or involving the command station. Devices on the network monitor the messages, check for format and data integrity and parse good messages to decode if action is required in the context. Devices such as throttles, input sensors, computer interfaces and control panels may generate the network messages without needing prompting or polling by a central controller.

Devices frequently will be added and removed from an operating the network. The devices and protocol are tolerant of electrical and data transients. The format chosen gives a good degree of data integrity, guaranteed quick network-state synchronisation, high data throughput, good distribution of access to many competing devices and low event latency. Also, the devices may be operated without need for unique ID or other requirements that can make network administration awkward.

The data bytes on the network are defined as 8 bit data with the most significant bit as an opcode flag bit. If the most significant bit, d7, is 1 then the 7 least significant bits are interpreted as a network opcode . The opcode byte may only occur once in a valid message and is the first byte of a message. The opcode does not necessarily uniquely identify a message type. Sometimes the opcode must be used in combination of other bits or bytes in the message. All the remaining bytes in the message must have a most significant bit of 0, including the last checksum byte. The checksum is the 1's complement of the byte wise exclusive or of all the bytes in the message, except the checksum itself. To validate data accuracy, all the bytes in a correctly formatted message are exclusive or'ed. If this resulting byte value is 0xFF, then the message data is accepted as good.

The opcodes may be examined to determine message length and if subsequent response message is required. Data bits d6 and d5 encode the message length. The message length includes the opcode and the checksum bytes. The bit d3 = 1 implies that a follow-on message or reply is expected. For variable byte messages  The byte following the opcode in the message is a 7 bit byte count.

\begin{tabular}{p{0.05\linewidth} p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth} p{0.36\linewidth}} 
\underline{d7} & \underline{d6} & \underline{d5} & \underline{d4} & \underline{d3} & \underline{d2} & \underline{d1} & \underline{d0} & \\
1 & 0 & 0 & E & D & C & B & A & 2 byte message\\
1 & 0 & 1 & E & D & C & B & A & 4 byte message\\
1 & 1 & 0 & E & D & C & B & A & 6 byte message\\
1 & 1 & 1 & E & D & C & B & A & Variable length message.\\
\end{tabular}

The A,B,C,D,E are bits available to encode 32 opcodes per message length.

\section{Refresh Slots}

The command station's refresh stack is used to control the locomotives. The refresh stack is an array of read/write refresh slots. There are two protocols for manipulating the refresh slots. Protocol 1 allows up to 120 locomotive slots and each slot contains 10 bytes of data relating to the locomotive. Protocol 2 allows up to 960 locomotive slots and each slot contains 15 bytes of data relating to the locomotive. Not all command stations implement both protocols. A command station may also not implement the maximum number of locomotive slots for the protocols it supports. Where a command station implements both protocols messages from both protocols can be freely mixed. The user should check the TRK status bits to determine if protocol 1 and/or 2 are supported. In this document message mnemonics that are suffixed ``P1" belong to protocol 1 and those suffixed ``P2" belong to protocol 2. The slot number is a principal component of the protocol and is similar to a file handle. In addition to the locomotive slots there are slots reserved for system and command station control. These slots are numbered 120 to 127 (0x78 to 0x7F) and are encoded differently from the locomotive slots. Slot 124 (0x7C) is allocated for read/write access to the programming track and slot 127 (0x7F) contains the command station configuration settings.

\section{Standard Address Selection}

To request a mobile or locomotive decoder task in the refresh stack, a throttle device requests a slot for the locomotive address by sending either the \textbf{getLocoSlotDataSAdr} or \textbf{getLocoSlotDataLAdr} commands. Which one depends on what type of decoder address you are using - short 2 digit or long 4 diigit. The command station responds with \textbf{LocoSlotData} messaage that contains this locomotive address and all of its state information. If the address is currently not in any slot, the command station will load this new locomotive address into a new slot (speed=0, direction forwards, functions off and 128 step mode) and return this as a \textbf{LocoSlotData}. If no inactive slots are free to load the new locomotive address, the response will be the \textbf{Ack} with a fail code 0x00.

The throttle/computer must then examine the slot data bytes to work out how to process the command station response. If the slot status 1 byte shows the slot to be ``common'', ``idle" or ``new" the throttle may change the slot to ``in use" by performing a null move instruction on this slot (see \textbf{MoveSlots}). This activation mechanism is used to guarantee proper slot usage interlocking in a multi-user asynchronous environment.

If the slot return information shows the locomotive requested is ``in use" or up-consisted (i.e. the SL\_CONUP, bit 6 of slot status 1 = 1) the user should not use the slot. Any up-consisted locomotives must be unlinked before usage. Always process the result from the \textbf{LinkSlots} and \textbf{UnlinkSlots} commands, since the command station reserves the right to change the reply slot number and can reject the linking tasks under several circumstances. Verify the reply slot number and the link UP/DN bits in slot status 1 are as you expected.

The throttle will then be able to update speed, direction and function information. Whenever slot information is changed in an active slot , the slot is flagged to be updated as the next DCC packet sent to the track. If the slot is part of linked consist slots the whole consist chain is updated consecutively.

If a throttle is disconnected from the the Network, upon reconnection (if the throttle retains the slot state from before disconnection) it will request the full status of the slot it was previously using. If the reported status and speed, function data etc., from the command station exactly matches the remembered slot state the throttle will continue using the slot. If the slot data does not match, the throttle will assume the slot was purged free by the system and will go through the setup log on procedure again.

With this procedure the throttle does not need to have a unique ID number. slot addresses do not imply they contain any particular locomotive address. The system can be mapped such that the slot address matches the locomotive address within, if the user directly reads and writes to slots without using the command station to allocate locomotive addresses.

\section{Messages}

The following information is provided for each of the messages:

\underline{Description:}

Description of the message's function.

\underline{Protocol:}

Which protocol the message belongs to.

\underline{Group:}

Which message size group the message belongs to.

\underline{Opcode:}

The opcode mnemonic.

\underline{Type:}

The message type - broadcast, command, response, or message.

\underline{Encoding:} 

How the message is encoded byte by byte.

\underline{Response:} 

The response expected from a command message, if applicable.

\underline{Signature:}

The bits and bytes that must be tested to determine the message's unique type.

\underline{Notes:} 

Any notes.

\input{Chapter1-Ack}
\input{Chapter1-Busy}
\input{Chapter1-CfgSlotDataP1}
\input{Chapter1-ConsistDirF0F4}
\input{Chapter1-GetBrdOpSw}
\input{Chapter1-GetCfgSlotDataP1}
\input{Chapter1-GetInterfaceData}
\input{Chapter1-GetLocoSlotDataLAdrP1}
\input{Chapter1-GetLocoSlotDataLAdrP2}
\input{Chapter1-GetLocoSlotDataP1}
\input{Chapter1-GetLocoSlotDataP2}
\input{Chapter1-GetLocoSlotDataSAdrP1}
\input{Chapter1-GetLocoSlotDataSAdrP2}
\input{Chapter1-IMMPacket}
\input{Chapter1-InterfaceData}
\input{Chapter1-LinkSlots}
\input{Chapter1-LocoBinStateP2}
\input{Chapter1-LocoDirF0F4P1}
\input{Chapter1-LocoDirF0F4P2}
\input{Chapter1-LocoF5F8P1}
\input{Chapter1-LocoF5F11P2}
\input{Chapter1-LocoF12F20F28P2}
\input{Chapter1-LocoF13F19P2}
\input{Chapter1-LocoF21F27P2}
\input{Chapter1-LocoSlotDataP1}
\input{Chapter1-LocoSlotDataP2}
\input{Chapter1-LocoSpdP1}
\input{Chapter1-LocoSpdP2}
\input{Chapter1-MoveSlotsP1}
\input{Chapter1-MoveSlotsP2}
\input{Chapter1-PeerXfer16}
\input{Chapter1-PeerXfer20}
\input{Chapter1-PwrOff}
\input{Chapter1-PwrOn}
\input{Chapter1-Reset}
\input{Chapter1-SensRepGIn}
\input{Chapter1-SensRepTIn}
\input{Chapter1-SensRepTOut}
\input{Chapter1-SetBrdOpSw}
\input{Chapter1-SetIdleState}
\input{Chapter1-SetLocoSlotDataP1}
\input{Chapter1-SetLocoSlotDataP2}
\input{Chapter1-SlotStat1}
\input{Chapter1-SVProg}
\input{Chapter1-SWAck}
\input{Chapter1-SWReq}
\input{Chapter1-SWState}
\input{Chapter1-TransRep}
\input{Chapter1-UnlinkSlots}

--------------------

PR4 Interface Status Message

\begin{verbatim}

PR4 #1

<D0> 0xe5 OPCODE
<D1> 0x10 LENGTH
<D2> 0x22 SRC
<D3> 0x22 DSTL
<D4> 0x01 DSTH
<D5> 0x00 PXCT1 <- I would have expected b4 = 1
<D6> 0x08 Serial Number Low Byte
<D7> 0x07 Serial Number High Byte - Actual serial number 0x0788
<D8> 0x16 
<D9> 0x00 
<D10> 0x00 PXCT2
<D11> 0x00 
<D12> 0x00 
<D13> 0x00 
<D14> 0x24 Product Code for PR4
<D15> 0x36  CHSUM

PR4 #2

<D0> 0xe5 OPCODE OPC_PEER_XFER
<D1> 0x10 LENGTH
<D2> 0x22 SRC
<D3> 0x22 DSTL
<D4> 0x01 DSTH
<D5> 0x00 PXCT1 
<D6> 0x57 Serial Number Low Byte
<D7> 0x13 Serial Number High Byte - Actual serial number 0x1357
<D8> 0x16 
<D9> 0x00 
<D10> 0x00 PXCT2
<D11> 0x00 
<D12> 0x00 
<D13> 0x00 
<D14> 0x24 Product Code for PR4
<D15> 0x7d CHKSUM

DCS240

<D0> 0xe5 OPCODE
<D1> 0x10 Length
<D2> 0x22 SRC
<D3> 0x22 DSTL
<D4> 0x01 DSTH
<D5> 0x00 PXCT1 <- I would have expected b4 to be 1
<D6> 0x2b Serial Number Low Byte
<D7> 0x0a  Serial Number High Byte - Actual serial number 0x0aab
<D8> 0x14 
<D9> 0x00 
<D10> 0x00 PXCT2
<D11> 0x01 Hardware Version?
<D12> 0x03 Software Version
<D13> 0x01 Hardware Version?
<D14> 0x1c Product Code for DCS240
<D15> 0x21

\end{verbatim}
