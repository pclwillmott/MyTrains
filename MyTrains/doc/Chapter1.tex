% Activate the following line by filling in the right side. If for example the name of the root file is Main.tex, write
% "...root = Main.tex" if the chapter file is in the same directory, and "...root = ../Main.tex" if the chapter is in a subdirectory.
 
%!TEX root =  

\chapter[Network Protocol]{The Network Protocol}.  

\section{Overview}

\Gls{Loconet} is a \gls{peer-to-peer} distributed network system on which all devices can monitor the network data flow. The network is event driven by different devices in time, and is not \gls{polled} by a centralised controller in normal operation. The normal network state is quiet, with no data traffic unless a device has information to send.

The network data is sent in asynchronous format using 1 start bit, 8 data bits and 1 stop bit. The 8 bit data is transmitted least significant bit first. The bit times are 60.0 $\mu$S or 16,660 baud +/- 1.5\%. A computer can connect to a Digitrax USB interface at higher baud rates and the device will make the necessary conversion. Bytes may be transmitted back-to-back, with a start bit immediately following the stop bit of the previous character. 

All the network communications are via multi-byte messages. The \gls{command station} is the device that maintains the refresh stack for \gls{DCC} packet generation and generates the DCC track data. Refresh of information is typically only performed for a \gls{mobile decoder}. A \gls{stationary decoder} is not refreshed and individual immediate commands are sent out to the track as requested.

The command station is only privileged in respect to performing the task of maintaining the locomotive refresh stack and generating DCC packets. In this way other network transactions may occur that the command station does not need to be involved with or understand, as long as they follow the message protocol and timing requirements. i.e. other devices may have a dialog on the network without disturbing or involving the command station. Devices on the network monitor the messages, check for format and data integrity and parse good messages to decode if action is required in the context. Devices such as throttles, input sensors, computer interfaces and control panels may generate the network messages without needing prompting or \gls{polling} by a central controller.

Devices frequently will be added and removed from an operating the network. The devices and protocol are tolerant of electrical and data transients. The format chosen gives a good degree of data integrity, guaranteed quick network-state synchronisation, high data throughput, good distribution of access to many competing devices and low event latency. 

\section{Message Format}

The data bytes on the network are defined as 8 bit data with the most significant bit as an \gls{opcode} flag bit. If the most significant bit is 1, then the 7 least significant bits are interpreted as a network opcode. The opcode byte may only occur once in a valid message and is the first byte of a message. The opcode does not necessarily uniquely identify a message type. Sometimes the opcode must be used in combination with other bits or bytes in the message to determine the message type signature. All the remaining bytes in the message must have a most significant bit of 0, including the last checksum byte. The checksum is the 1's complement of the byte wise exclusive or of all the bytes in the message, except the checksum itself. To validate data accuracy, all the bytes in a correctly formatted message are exclusive or'ed. If this resulting byte value is 0xFF, then the message data is accepted as good. Any message that has format or framing errors, data errors or is a fragment caused by noise glitches and does not completely follow the message format will be ignored by all receivers, and a new opcode will be scanned for re-synchronisation.

The opcodes may be examined to determine message length and if subsequent response message is required. Data bits d6 and d5 encode the message length. The message length includes the opcode and the checksum bytes. When bit d3 equals 1 a follow-on message or reply is expected. For variable byte messages the byte following the opcode in the message is a 7 bit byte count.

\begin{tabular}{p{0.05\linewidth} p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth}  p{0.05\linewidth} p{0.36\linewidth}} 
\underline{d7} & \underline{d6} & \underline{d5} & \underline{d4} & \underline{d3} & \underline{d2} & \underline{d1} & \underline{d0} & \\
1 & 0 & 0 & E & D & C & B & A & 2 byte message\\
1 & 0 & 1 & E & D & C & B & A & 4 byte message\\
1 & 1 & 0 & E & D & C & B & A & 6 byte message\\
1 & 1 & 1 & E & D & C & B & A & Variable length message.\\
\end{tabular}

The A,B,C,D,E are bits available to encode 32 opcodes per message length.

\section{Slots}

The command station contains an array of read/write slots. There are two classes of slots (\gls{locomotive slot} and \gls{system slot}) and two protocols for manipulating the slots. Protocol 1 allows up to 120 locomotive slots and each slot contains 10 bytes of data relating to the locomotive. Protocol 2 allows up to 960 locomotive slots and each slot contains 15 bytes of data relating to the locomotive. Not all command stations implement both protocols. A command station may also not implement the maximum number of locomotive slots for the protocols it supports. Where a command station implements both protocols messages from both protocols can be freely mixed. The user should check the \gls{Global System Track Status} bits in a \textbf{LocoSlotDataP1} or \textbf{LocoSlotDataP2} response to determine which protocols are supported. In this document message mnemonics that are suffixed ``P1" belong to protocol 1 and those suffixed ``P2" belong to protocol 2. Protocol 1 uses a single 7 bit number to identify a slot. Protocol 2 uses a 3 bit number to identify the page or bank of slots and a 7 bit number to identify the slot within the page or bank. In both protocols slots numbered 0 to 119 (0x00 to 0x77) are locomotive slots and those numbered 120 to 127 (0x78 to 0x7F) are system slots. The slot number is similar to a file handle. System slots are encoded differently from the locomotive slots. 

\begin{tabular}{l l}
\underline{System Slot\#} & \underline{Description}\\
123 (0x7B) & Fast Clock\\
124 (0x7C & Programming Interface\\
127 (0x7F) & Option Switch Settings\\
\end{tabular}

Initially all locomotive slots are empty and are said to be Free. A Free slot does not have a locomotive address loaded and no DCC commands are generated by the command station for it. To control a locomotive a \gls{throttle} must request a slot from the command station and take ownership of it.

\subsection{Slot State}

A locomotive slot's \gls{slot state} is determined by bits d5 and d4 of the \gls{Slot Status 1} byte of the applicable \textbf{LocoSlotData1} or \textbf{LocoSlotDataP2} response and whether the locomotive's address has been loaded. The slot state determines whether DCC commands are generated for it and if throttles can take control of it.

\begin{tabular}{l l l l l l}
\underline{Slot State} & \underline{d5} & \underline{d4} & \underline{Address Loaded} & \underline{Decoder Refreshed} & \underline{Any Throttle}\\
Free & 0 & 0 & No & No & Yes\\
New & 0 & 0 & Yes & No & Yes\\
Common & 0 & 1 & Yes & Yes & Yes\\
Idle & 1 & 0 & Yes & No & Yes\\
In-Use & 1 & 1 & Yes & Yes & No\\
\end{tabular}

\subsection{Throttle ID}

The \gls{Throttle ID} for a \gls{physical throttle} is derived from the throttle's serial number. Digitrax serial numbers are 16-bit numbers. The Throttle ID is split into two parts consisting of the least significant bits of the low and high bytes of the serial number respectively. For example a physical throttle with the serial number of 0xFFFE would have a Throttle ID of 0x7E 0x7F with 0x7E being the low byte. The low byte of the Throttle ID is required by some of the protocol 2 commands to ensure that only the throttle that has ownership of the locomotive slot is the one that updates the slot. A \gls{software throttle} should choose a Throttle ID that does not clash with that of a physical throttle.

\subsection{Protocol 1}

\begin{enumerate}
\item The throttle requests a slot for the locomotive \gls{address} by sending either a \textbf{GetLocoSlotDataSAdrP1} or \textbf{GetLocoSlotDataLAdrP1} request to the command station. Which one depends on what type of address the locomotive's decoder is programmed to use. 
\item If a slot has been previously loaded with the locomotive's address, then the command station will return a \textbf{LocoSlotDataP1} response.
\item If the locomotive's address is not currently in a slot, then the command station will load the new locomotive address into a Free slot, with speed equal to zero, direction forwards, functions off and 128 step mode, and return a \textbf{LocoSlotDataP1} response.
\item If there are no Free slots to load the new locomotive address into, the command station with return a \textbf{NoFreeSlotsP1} response and this procedure is terminated.
\item The throttle must then examine the slot data bytes to work out how to process the command station response.
\item If the slot state is New, Common or Idle then the throttle requests a ``null move" operation by sending the command station a \textbf{MoveSlotsP1} request. The command station returns a \textbf{LocoSlotDataP1} response. 
\item If the slot state is In-Use and the slot's \gls{Throttle ID} does not match that of the throttle then the throttle should ask the user if they wish to ``steal" the slot. If the answer is no then this procedure is terminated.
\item The throttle now takes ownership of the slot by updating the slot's Throttle ID to that of the throttle and writing the updated slot data to the command station by sending a \textbf{SetLocoSlotDataP1} request. If the request is successful then the command station will return a \textbf{setSlotDataOKP1} response.
\item The throttle will then be able to update speed, direction and function information. Whenever slot information is changed in an active slot, the slot is flagged to be updated as the next DCC packet sent to the track.
\end{enumerate}

\subsection{Protocol 2}

\begin{enumerate}
\item The throttle requests a slot for the locomotive \gls{address} by sending either a \textbf{GetLocoSlotDataSAdrP2} or \textbf{GetLocoSlotDataLAdrP2} request to the command station. Which one depends on what type of address the locomotive's decoder is programmed to use. 
\item If a slot has been previously loaded with the locomotive's address, then the command station will return a \textbf{LocoSlotDataP2} response.
\item If the locomotive's address is not currently in a slot, then the command station will load the new locomotive address into a Free slot, with speed equal to zero, direction forwards, functions off and 128 step mode, and return a \textbf{LocoSlotDataP2} response.
\item If there are no Free slots to load the new locomotive address into, the command station with return a \textbf{NoFreeSlotsP2} response and this procedure is terminated.
\item The throttle must then examine the slot data bytes to work out how to process the command station response.
\item If the slot state is New, Common or Idle then the throttle requests a ``null move" operation by sending the command station a \textbf{MoveSlotsP2} request. The command station returns a \textbf{LocoSlotDataP2} response. 
\item If the slot state is In-Use and the slot's \gls{Throttle ID} does not match that of the throttle then the throttle should ask the user if they wish to ``steal" the slot. If the answer is no then this procedure is terminated.
\item The throttle now takes ownership of the slot by updating the slot's Throttle ID to that of the throttle and writing the updated slot data to the command station by sending a \textbf{SetLocoSlotDataP2} request. If the request is successful then the command station will return a \textbf{setSlotDataOKP2} response.
\item The throttle will then be able to update speed, direction and function information. Whenever slot information is changed in an active slot, the slot is flagged to be updated as the next DCC packet sent to the track.
\end{enumerate}

Example:

\begin{verbatim}
getLocoSlotDataSAdrP2
     0xbe 0x00 0x17 0x56 
     
locoSlotDataP2
     0xe6 0x15 0x01 0x05 0x03 0x17 0x00 0x47 0x00 0x00 
     0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x5b 

moveSlotsP2
     0xd4 0x39 0x05 0x01 0x05 0x13 

locoSlotDataP2
     0xe6 0x15 0x01 0x05 0x33 0x17 0x00 0x47 0x00 0x00 
     0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x6b 

setLocoSlotDataP2
     0xee 0x15 0x01 0x05 0x33 0x17 0x00 0x47 0x00 0x00 
     0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x6d 0x52 0x5c 

setSlotDataOKP2
     0xb4 0x6e 0x7f 0x5a 
\end{verbatim}
\normalsize

\subsection{Purging}
If a device disconnects from the network and so does not access or reference a slot within the system purge time, the command station will force the un-accessed slot to \gls{Common} status so other system devices can use the slot. The typical purge time of a command station is about 200 seconds. A good ``ping" or slot update activity is about every 100 seconds, i.e. if a user makes no change to a throttle/slot within 100 seconds, the throttle/device should automatically send another speed update at the current speed to reset the purge timeout for that slot.

\newpage
\section{Messages}

The following information is provided for each of the messages:

\underline{Description:}

Description of the message's function.

\underline{Protocol:}

Which protocol the message belongs to. Only messages that relate to refresh slots belong to a protocol.

\underline{Group:}

Which message size group the message belongs to.

\underline{Opcode:}

The opcode mnemonic. This is the Digitrax assigned mnemonic when known.

\underline{Type:}

The message type - broadcast, command, response, or message.

\underline{Encoding:} 

How the message is encoded byte by byte.

\underline{Response:} 

The response expected from a command message, if applicable.

\underline{Signature:}

The bits and bytes that must be tested to determine the message's unique type.

\underline{Notes:} 

Any notes.

\input{Chapter1-Ack}
\input{Chapter1-Busy}
\input{Chapter1-CfgSlotDataP1}
\input{Chapter1-ConsistDirF0F4}
\input{Chapter1-GetBrdOpSw}
\input{Chapter1-GetCfgSlotDataP1}
\input{Chapter1-GetInterfaceData}
\input{Chapter1-GetLocoSlotDataLAdrP1}
\input{Chapter1-GetLocoSlotDataLAdrP2}
\input{Chapter1-GetLocoSlotDataP1}
\input{Chapter1-GetLocoSlotDataP2}
\input{Chapter1-GetLocoSlotDataSAdrP1}
\input{Chapter1-GetLocoSlotDataSAdrP2}
\input{Chapter1-IMMPacket}
\input{Chapter1-InterfaceData}
\input{Chapter1-IPLDataLoad}
\input{Chapter1-IPLDevData}
\input{Chapter1-IPLDiscover}
\input{Chapter1-IPLEndLoad}
\input{Chapter1-IPLSetAddr}
\input{Chapter1-IPLSetupBL2}
\input{Chapter1-LinkSlotsP1}
\input{Chapter1-LinkSlotsP2}
\input{Chapter1-LocoBinStateP2}
\input{Chapter1-LocoDirF0F4P1}
\input{Chapter1-LocoDirF0F4P2}
\input{Chapter1-LocoF0F6P2}
\input{Chapter1-LocoF5F8P1}
\input{Chapter1-LocoF7F13P2}
\input{Chapter1-LocoF5F11P2}
\input{Chapter1-LocoF12F20F28P2}
\input{Chapter1-LocoF13F19P2}
\input{Chapter1-LocoF14F20P2}
\input{Chapter1-LocoF21F27P2}
\input{Chapter1-LocoF21F28P2}
\input{Chapter1-LocoSlotDataP1}
\input{Chapter1-LocoSlotDataP2}
\input{Chapter1-LocoSpdP1}
\input{Chapter1-LocoSpdP2}
\input{Chapter1-LocoSpdDirP2}
\input{Chapter1-MoveSlotsP1}
\input{Chapter1-MoveSlotsP2}
\input{Chapter1-PeerXfer16}
\input{Chapter1-ProgCV}
\input{Chapter1-ProgSlotDataP1}
\input{Chapter1-PwrOff}
\input{Chapter1-PwrOn}
\input{Chapter1-Reset}
\input{Chapter1-SensRepGenIn}
\input{Chapter1-SensRepTurnIn}
\input{Chapter1-SensRepTurnOut}
\input{Chapter1-SetBrdOpSw}
\input{Chapter1-SetIdleState}
\input{Chapter1-SetLocoSlotDataP1}
\input{Chapter1-SetLocoSlotDataP2}
\input{Chapter1-SetLocoSlotStat1}
\input{Chapter1-SetSWWithAck}
\input{Chapter1-SVProg}
\input{Chapter1-SWReq}
\input{Chapter1-SWState}
\input{Chapter1-TransRep}
\input{Chapter1-UnlinkSlotsP1}
\input{Chapter1-UnlinkSlotsP2}
